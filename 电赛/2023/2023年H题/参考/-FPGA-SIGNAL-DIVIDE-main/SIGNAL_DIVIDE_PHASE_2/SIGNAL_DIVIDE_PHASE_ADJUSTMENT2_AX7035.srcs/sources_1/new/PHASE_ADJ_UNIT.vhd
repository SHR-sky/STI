LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.FIXED_PKG.ALL;

ENTITY PHASE_ADJ_UNIT IS 
PORT(
  ACLK:IN STD_LOGIC;
  ARESETN:IN STD_LOGIC;
  PHASE_IN_JD:IN STD_LOGIC_VECTOR(15 DOWNTO 0); --½Ç¶È
  RE_IN:IN SFIXED(11 DOWNTO 0);
  IM_IN:IN SFIXED(11 DOWNTO 0);
  VALID_IN:IN STD_LOGIC;
  RE_OUT:OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
  IM_OUT:OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
  VALID_OUT:OUT STD_LOGIC
);
END ENTITY;

ARCHITECTURE BEHAVE OF PHASE_ADJ_UNIT IS

COMPONENT SQUARE_0
  PORT (
    aclk : IN STD_LOGIC;
    ARESETN:IN STD_LOGIC;
    s_axis_cartesian_tvalid : IN STD_LOGIC;
    s_axis_cartesian_tdata : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
    m_axis_dout_tvalid : OUT STD_LOGIC;
    m_axis_dout_tdata : OUT STD_LOGIC_VECTOR(15 DOWNTO 0) 
  );
END COMPONENT;

COMPONENT LUT1_GEN IS 
PORT(
  ACLK:IN STD_LOGIC;
  ADDR:IN STD_LOGIC_VECTOR(15 DOWNTO 0);
  DOUT:OUT STD_LOGIC_VECTOR(23 DOWNTO 0)
);
END COMPONENT;

COMPONENT LUT2_GEN IS 
PORT(
  ACLK:IN STD_LOGIC;
  ADDR:IN STD_LOGIC_VECTOR(15 DOWNTO 0);
  DOUT:OUT STD_LOGIC_VECTOR(23 DOWNTO 0)
);
END COMPONENT;

COMPONENT PHASE_DATA_TRANS IS 
GENERIC(
  WIDTH:INTEGER:= 25
);
PORT(
  DIN:IN STD_LOGIC_VECTOR(WIDTH - 1 DOWNTO 0);
  DOUT:OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
);
END COMPONENT;

COMPONENT MUL_0
  PORT (
    CLK : IN STD_LOGIC;
    A : IN SFIXED(31 DOWNTO -6);
    B : IN SFIXED(6 DOWNTO -17);
    P : OUT SFIXED(38 DOWNTO -23) 
  );
END COMPONENT;

TYPE STATES IS (S_IDLE,S_STEP1,S_STEP2,S_STEP3,S_STEP4,S_STEP5,S_STEP6,S_STEP7,S_STEP8,S_STEP9,S_STEP10,S_FINISH);
SIGNAL STATE:STATES:= S_IDLE;

SIGNAL LUT1_ADDR:STD_LOGIC_VECTOR(15 DOWNTO 0):= (OTHERS => '0');
SIGNAL LUT1_DOUT:STD_LOGIC_VECTOR(23 DOWNTO 0):= (OTHERS => '0');

SIGNAL LUT2_ADDR:STD_LOGIC_VECTOR(15 DOWNTO 0):= (OTHERS => '0');
SIGNAL LUT2_DOUT:STD_LOGIC_VECTOR(23 DOWNTO 0):= (OTHERS => '0');

SIGNAL RE2:SFIXED(23 DOWNTO 0):= (OTHERS => '0');
SIGNAL IM2:SFIXED(23 DOWNTO 0):= (OTHERS => '0');

SIGNAL RE2_AND_IM2:SFIXED(24 DOWNTO 0):= (OTHERS => '0');

SIGNAL SQUARE_IN:STD_LOGIC_VECTOR(31 DOWNTO 0):= (OTHERS => '0');
SIGNAL SQUARE_IN_VALID:STD_LOGIC:= '0';
SIGNAL SQUARE_OUT:STD_LOGIC_VECTOR(15 DOWNTO 0):= (OTHERS => '0');
SIGNAL SQUARE_OUT_VALID:STD_LOGIC:= '0';

SIGNAL PART_1:SFIXED(13 DOWNTO 0):= (OTHERS => '0');
SIGNAL PART_2:SFIXED(1 DOWNTO -22):= (OTHERS => '0');

SIGNAL PART_ALL:SFIXED(15 DOWNTO -22):= (OTHERS => '0');
SIGNAL TANF:SFIXED(6 DOWNTO -17):= (OTHERS => '0');

SIGNAL RE_OUT_R:SFIXED(15 DOWNTO -22):= (OTHERS => '0');
SIGNAL IM_OUT_R:SFIXED(22 DOWNTO -39):= (OTHERS => '0');

SIGNAL DATA_0:STD_LOGIC_VECTOR(15 DOWNTO 0):= (OTHERS => '0');
SIGNAL DATA_1:STD_LOGIC_VECTOR(22 DOWNTO 0):= (OTHERS => '0');

SIGNAL PHASE_IN_R:STD_LOGIC_VECTOR(15 DOWNTO 0):= (OTHERS => '0');

BEGIN

  PROCESS IS BEGIN
  WAIT UNTIL RISING_EDGE(ACLK);
    IF ARESETN = '0' THEN
      RE2 <= (OTHERS => '0');
      IM2 <= (OTHERS => '0');
      RE2_AND_IM2 <= (OTHERS => '0');
      PART_1 <= (OTHERS => '0');
      PART_2 <= (OTHERS => '0');
      PART_ALL <= (OTHERS => '0');
      TANF <= (OTHERS => '0');
      SQUARE_IN_VALID <= '0';
      LUT1_ADDR <= (OTHERS => '0');
      LUT2_ADDR <= (OTHERS => '0');
      RE_OUT_R <= (OTHERS => '0');
      IM_OUT_R <= (OTHERS => '0');
      VALID_OUT <= '0';
      PHASE_IN_R <= (OTHERS => '0');
    ELSE
      CASE STATE IS 
        WHEN S_IDLE =>
          VALID_OUT <= '0';
          IF VALID_IN = '1' THEN
            RE2 <= RE_IN * RE_IN;
            IM2 <= IM_IN * IM_IN;
            PHASE_IN_R <= PHASE_IN_JD;
            STATE <= S_STEP1;
          ELSE
            RE2 <= (OTHERS => '0');
            IM2 <= (OTHERS => '0');
          END IF;
        WHEN S_STEP1 =>
          LUT1_ADDR <= PHASE_IN_R;
          LUT2_ADDR <= PHASE_IN_R;
          RE2_AND_IM2 <= RE2 + IM2;
          STATE <= S_STEP2;
        WHEN S_STEP2 =>
          SQUARE_IN <= "0000000" & TO_SLV(RE2_AND_IM2);
          SQUARE_IN_VALID <= '1';
          STATE <= S_STEP3;
        WHEN S_STEP3 =>
          IF SQUARE_OUT_VALID = '1' THEN
            PART_1 <= TO_SFIXED(('0' & SQUARE_OUT(12 DOWNTO 0)),13,0);
            STATE <= S_STEP4;
          END IF;
        WHEN S_STEP4 =>
          SQUARE_IN_VALID <= '0';
          PART_2 <= TO_SFIXED(LUT1_DOUT,6,-17);
          STATE <= S_STEP5;
        WHEN S_STEP5 =>
          PART_ALL <= PART_1 * PART_2;
          TANF <= TO_SFIXED(LUT2_DOUT,6,-17);
          STATE <= S_STEP6;
        WHEN S_STEP6 =>
          STATE <= S_STEP7;
        WHEN S_STEP7 =>
          STATE <= S_STEP8;
        WHEN S_STEP8 =>
          IM_OUT_R <= PART_ALL * TANF;
          IF PHASE_IN_R = X"0000" THEN 
            RE_OUT_R <= (OTHERS => '0');
          ELSIF PHASE_IN_R = X"00B4" THEN
            RE_OUT_R <= (OTHERS => '0');
          ELSE
            RE_OUT_R <= PART_ALL;
          END IF;
          STATE <= S_STEP9;
        WHEN S_STEP9 =>
          DATA_0 <= TO_SLV(RE_OUT_R(15 DOWNTO 0));
          DATA_1 <= TO_SLV(IM_OUT_R(22 DOWNTO 0));
          STATE <= S_FINISH;
        WHEN S_FINISH =>
          VALID_OUT <= '1';
          STATE <= S_IDLE;
        WHEN OTHERS => 
          STATE <= S_IDLE;
      END CASE;
    END IF;
  END PROCESS;
          
  LUT1_GEN_GEN:LUT1_GEN PORT MAP
  (
    ACLK => ACLK,
    ADDR => LUT1_ADDR,
    DOUT => LUT1_DOUT
  );        
  
   LUT2_GEN_GEN:LUT2_GEN PORT MAP
  (
    ACLK => ACLK,
    ADDR => LUT2_ADDR,
    DOUT => LUT2_DOUT
  );                

  SQUARE_0_GEN : SQUARE_0
  PORT MAP (
    aclk => ACLK,
    aresetn => ARESETN,
    s_axis_cartesian_tvalid => SQUARE_IN_VALID,
    s_axis_cartesian_tdata => SQUARE_IN,
    m_axis_dout_tvalid => SQUARE_OUT_VALID,
    m_axis_dout_tdata => SQUARE_OUT
  );
  
  T0:PHASE_DATA_TRANS GENERIC MAP
  (
    WIDTH => 16
  )
  PORT MAP
  (
    DIN => DATA_0,
    DOUT => RE_OUT 
  );
  
  T1:PHASE_DATA_TRANS GENERIC MAP
  (
    WIDTH => 23
  )
  PORT MAP
  (
    DIN => DATA_1,
    DOUT => IM_OUT 
  );

END ARCHITECTURE;