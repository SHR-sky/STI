LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
USE IEEE.STD_LOGIC_SIGNED.ALL;

ENTITY PHASE_ADJUSTMENT IS 
PORT
(
  ACLK:IN STD_LOGIC;
  ARESETN:IN STD_LOGIC;
  VALID_IN:IN STD_LOGIC;
  PHASE_IN:IN STD_LOGIC_VECTOR(15 DOWNTO 0);
  RE_IN_0:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  IM_IN_0:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  RE_IN_1:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  IM_IN_1:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  VALID_OUT_0:OUT STD_LOGIC;
  VALID_OUT_1:OUT STD_LOGIC;
  
  AF_IN:IN STD_LOGIC_VECTOR(7 DOWNTO 0);
  BF_IN:IN STD_LOGIC_VECTOR(7 DOWNTO 0);
  
  FFT_RAM0_ADDR:IN STD_LOGIC_VECTOR(15 DOWNTO 0);
  FFT_RAM0_DATA:OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
 
  FFT_RAM1_ADDR:IN STD_LOGIC_VECTOR(15 DOWNTO 0);
  FFT_RAM1_DATA:OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  
);
END ENTITY;

ARCHITECTURE BEHAVE OF PHASE_ADJUSTMENT IS 

COMPONENT PHASE_ADJ_UNIT IS 
PORT(
  ACLK:IN STD_LOGIC;
  ARESETN:IN STD_LOGIC;
  PHASE_IN_JD:IN STD_LOGIC_VECTOR(15 DOWNTO 0); --½Ç¶È
  RE_IN:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  IM_IN:IN STD_LOGIC_VECTOR(11 DOWNTO 0);
  VALID_IN:IN STD_LOGIC;
  RE_OUT:OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
  IM_OUT:OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
  VALID_OUT:OUT STD_LOGIC
);
END COMPONENT;

SIGNAL RE_OUT_0_R:STD_LOGIC_VECTOR(11 DOWNTO 0):= (OTHERS => '0');
SIGNAL IM_OUT_0_R:STD_LOGIC_VECTOR(11 DOWNTO 0):= (OTHERS => '0');

SIGNAL RE_OUT_1_R:STD_LOGIC_VECTOR(11 DOWNTO 0):= (OTHERS => '0');
SIGNAL IM_OUT_1_R:STD_LOGIC_VECTOR(11 DOWNTO 0):= (OTHERS => '0');

BEGIN

  U0:PHASE_ADJ_UNIT PORT MAP
  (
    ACLK => ACLK,
    ARESETN => ARESETN,
    PHASE_IN_JD => (OTHERS => '0'),
    RE_IN => RE_IN_0,
    IM_IN => IM_IN_0,
    VALID_IN => VALID_IN,
    RE_OUT => RE_OUT_0_R,
    IM_OUT => IM_OUT_0_R,
    VALID_OUT => VALID_OUT_0
  );

  U1:PHASE_ADJ_UNIT PORT MAP
  (
    ACLK => ACLK,
    ARESETN => ARESETN,
    PHASE_IN_JD => PHASE_IN,
    RE_IN => RE_IN_1,
    IM_IN => IM_IN_1,
    VALID_IN => VALID_IN,
    RE_OUT => RE_OUT_1_R,
    IM_OUT => IM_OUT_1_R,
    VALID_OUT => VALID_OUT_1
  );
  
  PROCESS IS BEGIN
  WAIT UNTIL RISING_EDGE(ACLK);
    IF FFT_RAM0_ADDR = 0 THEN
      FFT_RAM0_DATA <= (OTHERS => '0');
    ELSIF FFT_RAM0_ADDR = AF_IN THEN
      FFT_RAM0_DATA <= X"0" & IM_OUT_0_R & X"0" & RE_OUT_0_R;
    ELSE
      FFT_RAM0_DATA <= (OTHERS => '0');
    END IF;
  END PROCESS;             
  
  PROCESS IS BEGIN
  WAIT UNTIL RISING_EDGE(ACLK);
    IF FFT_RAM1_ADDR = 0 THEN
      FFT_RAM1_DATA <= (OTHERS => '0');
    ELSIF FFT_RAM1_ADDR = BF_IN THEN
      FFT_RAM1_DATA <= X"0" & IM_OUT_1_R & X"0" & RE_OUT_1_R;
    ELSE
      FFT_RAM1_DATA <= (OTHERS => '0');
    END IF;
  END PROCESS;   

END ARCHITECTURE;